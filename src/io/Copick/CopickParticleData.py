# vim: set expandtab shiftwidth=4 softtabstop=4:

# General
import json
import numpy as np
import pydantic
if pydantic.VERSION.startswith("1"):
    from pydantic import BaseModel, validator
elif pydantic.VERSION.startswith("2"):
    from pydantic.v1 import BaseModel, validator
else:
    raise ImportError(f"Unsupported pydantic version {pydantic.VERSION}.")
from typing import List, Literal, Optional, Union

# Chimerax
from chimerax.map import open_map
from chimerax.core.errors import UserError

# This package
from ..formats import ArtiaXFormat
from ..ParticleData import ParticleData, EulerRotation


class CopickLocation(BaseModel):
    x: float
    y: float
    z: float


class CopickPoint(BaseModel):
    location: CopickLocation
    transformation_: Optional[List[List[float]]] = [
        [1.0, 0.0, 0.0, 0.0],
        [0.0, 1.0, 0.0, 0.0],
        [0.0, 0.0, 1.0, 0.0],
        [0.0, 0.0, 0.0, 1.0],
    ]
    instance_id: Optional[int] = 0
    score: Optional[float] = 1.0

    class Config:
        arbitrary_types_allowed = True

    @validator("transformation_")
    def validate_transformation(cls, v) -> List[List[float]]:
        """Validate the transformation matrix."""
        arr = np.array(v)
        assert arr.shape == (4, 4), "transformation must be a 4x4 matrix."
        assert arr[3, 3] == 1.0, "Last element of transformation matrix must be 1.0."
        assert np.allclose(arr[3, :], [0.0, 0.0, 0.0, 1.0]), "Last row of transformation matrix must be [0, 0, 0, 1]."
        return v

    @property
    def transformation(self) -> np.ndarray:
        return np.array(self.transformation_)

    @transformation.setter
    def transformation(self, value: np.ndarray) -> None:
        assert value.shape == (4, 4), "Transformation must be a 4x4 matrix."
        assert value[3, 3] == 1.0, "Last element of transformation matrix must be 1.0."
        assert np.allclose(value[3, :], [0.0, 0.0, 0.0, 1.0]), "Last row of transformation matrix must be [0, 0, 0, 1]."
        self.transformation_ = value.tolist()


class CopickPicksFile(BaseModel):
    pickable_object_name: str
    """Pickable object name from CopickConfig.pickable_objects[X].name"""

    user_id: str
    """Unique identifier for the user or tool name."""

    session_id: Union[str, Literal["0"]]
    """Unique identifier for the pick session (prevent race if they run multiple instances of napari, ChimeraX, etc)
       If it is 0, this pick was generated by a tool."""

    run_name: Optional[str]
    """Name of the run this pick belongs to."""
    voxel_spacing: Optional[float]
    """Voxel spacing for the tomogram this pick belongs to."""
    unit: str = "angstrom"
    """Unit for the location of the pick."""

    points: Optional[List[CopickPoint]] = None
    """References to the points for this pick."""


class CopickEulerRotation(EulerRotation):

    def __init__(self):
        super().__init__(axis_1=(0, 0, 1), axis_2=(1, 0, 0), axis_3=(0, 0, 1))

    def rot1_from_matrix(self, matrix):
        """Phi"""
        matrix = np.clip(matrix, -1, 1, out=matrix)
        # Singularity check
        if matrix[2, 2] > 0.9999:
            angle = 0
        else:
            angle = np.arctan2(matrix[2, 0], matrix[2, 1]) * 180.0 / np.pi

        return angle

    def rot2_from_matrix(self, matrix):
        """Theta"""
        matrix = np.clip(matrix, -1, 1, out=matrix)

        angle = np.arctan2(np.sqrt(1 - (matrix[2, 2] * matrix[2, 2])), matrix[2, 2]) * 180.0 / np.pi

        return angle

    def rot3_from_matrix(self, matrix):
        """Psi"""
        matrix = np.clip(matrix, -1, 1, out=matrix)
        # Singularity check
        if matrix[2, 2] > 0.9999:
            angle = -1.0 * np.sign(matrix[0, 1]) * np.arccos(matrix[0, 0]) * 180.0/np.pi
        else:
            angle = np.arctan2(matrix[0, 2], -matrix[1, 2]) * 180.0 / np.pi

        return angle

class CopickParticleData(ParticleData):
    DATA_KEYS = {
        'location_x': ['location_x'],
        'location_y': ['location_y'],
        'location_z': ['location_z'],
        'score': ['score'],
        'instance_id': ['instance_id'],
        'shift_x': ['shift_x'],
        'shift_y': ['shift_y'],
        'shift_z': ['shift_z'],
        'phi': ['phi'],
        'the': ['the'],
        'psi': ['psi']
    }

    DEFAULT_PARAMS = {
        'pos_x': 'location_x',
        'pos_y': 'location_y',
        'pos_z': 'location_z',
        'shift_x': 'shift_x',
        'shift_y': 'shift_y',
        'shift_z': 'shift_z',
        'ang_1': 'phi',
        'ang_2': 'the',
        'ang_3': 'psi'
    }

    ROT = CopickEulerRotation

    def __init__(self, session, file_name, oripix=1, trapix=1, additional_files=None):
        self.picks = None

        super().__init__(session, file_name, oripix=oripix, trapix=trapix, additional_files=additional_files)


    def read_file(self):
        with open(self.file_name, "r") as f:
            data = json.load(f)

        self.picks = CopickPicksFile(**data)

        for point in self.picks.points:
            p = self.new_particle()

            p['score'] = point.score
            p['instance_id'] = point.instance_id
            p['location_x'] = point.location.x
            p['location_y'] = point.location.y
            p['location_z'] = point.location.z

            p.rotation = point.transformation[0:3, :]



    def write_file(self, file_name=None, additional_files=None):
        if file_name is None:
            file_name = self.file_name

        if self.picks is None:
            self.picks = CopickPicksFile(pickable_object_name="particle",
                                         user_id="ArtiaX",
                                         session_id="0",)

        self.picks.points = []
        for _id, p in self:
            rotmat = np.eye(4)
            rotmat[0:3, :] = p.rotation.matrix
            point = CopickPoint(
                location=CopickLocation(x=p['location_x'],
                                        y=p['location_y'],
                                        z=p['location_z']),
                transformation_=rotmat.tolist(),
                instance_id=p['instance_id'],
                score=p['score'])
            #point.transformation = rotmat
            self.picks.points.append(point)

        with open(file_name, "w") as f:
            json.dump(self.picks.dict(), f, indent=4)



COPICK_FORMAT = ArtiaXFormat(name='Copick Picks file',
                             nicks=['copick'],
                             particle_data=CopickParticleData)

